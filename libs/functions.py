# Here I will put the functions

import numpy as np
import random
from numba import jit


@jit(nopython=True)
def set_seed(seed):
    """
    Set the seed for Numba jit decorated 'random' function calls.

    Parameters
    ----------
    seed : int
        Seed value for random number generation.

    Returns
    -------
    None

    Raises
    ------
    None

    Notes
    -----
    This function sets the seed value for random number generation when using Numba jit decorated functions.
    It ensures that the random numbers generated by Numba jit are reproducible.

    Examples
    --------
    >>> set_seed(42)
    """
    np.random.seed(seed)
    random.seed(seed)


@jit(nopython=True)
def cellular_automaton_lu_ham_standard(B, N, Zc, iterations):
    """
    Apply cellular automaton rules to a grid.

    Parameters
    ----------
    B : numpy.ndarray
        Initial grid.
    N : int
        Size of the grid.
    Zc : float
        Parameter Zc.
    iterations : int
        Number of iterations.

    Returns
    -------
    tuple
        A tuple containing:
            - e_lib : List of energy values at each iteration.
            - e_tot : List of total energy values at each iteration.
            - final_grid : numpy.ndarray : Final grid state.
            - grid_states : List of grid states at each iteration.
            - area_states : List of corresponding area states.

    Raises
    ------
    None

    Notes
    -----
    This function applies cellular automaton rules to a grid represented by
    matrix `B`. It iterates for a specified number of times (`iterations`)
    and updates the grid state according to the specified rules.

    Examples
    --------
    >>> initial_grid = np.zeros((10, 10), dtype=np.float32)
    >>> energy_list, total_energy_list, final_grid, grid_states, area_states = cellular_automaton(initial_grid)
    """

    C = np.zeros((N+2, N+2), dtype=np.float32)  # Initialize C matrix
    M = np.zeros((N+2, N+2), dtype=np.float32)  # Initialize M matrix
    D = 2  # Dimension
    s = 2*D+1  # Calculate 's'
    grid_list = [B]  # Initialize list to store grids
    area_list = [B]  # Initialize list to store areas
    e_lib = []  # Initialize list to store e values
    e_tot = []  # Initialize list to store total energy values
    zc_s_over_s = Zc / s  # Calculate zc_s_over_s
    two_d_s_over_s_zc = ((2*D) / s) * Zc  # Calculate two_d_s_over_s_zc

    for i in range(iterations):
        e = 0  # Initialize energy variable

        # Iterate through the grid
        for j in range(1, N+1):
            for k in range(1, N+1):
                Z = B[j, k] - (1/(2*D)) * (B[j+1, k] +
                                           B[j-1, k] + B[j, k+1] + B[j, k-1])
                abs_z = abs(Z)

                # Check if condition is met for energy update
                if abs_z > Zc:
                    C[j, k] = C[j, k] - two_d_s_over_s_zc
                    C[j+1, k] = C[j+1, k] + zc_s_over_s
                    C[j-1, k] = C[j-1, k] + zc_s_over_s
                    C[j, k+1] = C[j, k+1] + zc_s_over_s
                    C[j, k-1] = C[j, k-1] + zc_s_over_s
                    M[j, k] = 1
                    M[j+1, k] = 1
                    M[j-1, k] = 1
                    M[j, k+1] = 1
                    M[j, k-1] = 1
                    g = two_d_s_over_s_zc * ((2*abs_z/Zc) - 1) * Zc
                    e = e + g
                else:
                    continue

        if e > 0:  # Update the grid if energy is positive
            B += C
            C = np.zeros((N+2, N+2), dtype=np.float32)
        else:  # Randomly update a cell if energy is non-positive
            k_prime = [random.randint(1, N+1), random.randint(1, N+1)]
            delta_B = random.random() - 0.2
            B[k_prime[0], k_prime[1]] = B[k_prime[0], k_prime[1]] + delta_B

        # Set boundary conditions
        B[0, :] = 0
        B[:, 0] = 0
        B[N+1, :] = 0
        B[:, N+1] = 0
        M[0, :] = 0
        M[:, 0] = 0
        M[N+1, :] = 0
        M[:, N+1] = 0

        # Append energy values to lists
        e_lib.append(e)
        e_tot.append(np.sum(np.square(B)))
        grid_list.append(B.copy())
        area_list.append(M)

        M = np.zeros((N+2, N+2), dtype=np.float32)  # Reset M matrix

    del grid_list[0]  # Delete initial grid from the list
    del area_list[0]  # Delete initial area from the list

    return e_lib, e_tot, B, grid_list, area_list  # Return the lists and final grid
